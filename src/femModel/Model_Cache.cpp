#include "Model.h"

bool g_ignoreCacheValidationWhenLoadingModelCache = false;

bool FemModel::loadCachedResults(){

    if(!fs::exists(m_resCachePath)){

        LOG << "** No Cache File found" << ENDL;
        LOG << "** Calculation ..." << ENDL;
        LOG << ENDL;

        return false;
    }

    ByteSequence bs;
    bs.fromFile(m_resCachePath);
    bs.decode(m_encoderKey);

    fileTime ftMesh, ftConstraints, ftMaterial;
    bs.extractMultiple(ftMaterial, ftConstraints, ftMesh);

    if(g_ignoreCacheValidationWhenLoadingModelCache){

    }
    else if(ftMesh != fs::last_write_time(m_meshPath) ||
        ftConstraints != fs::last_write_time(m_constraintPath) ||
        ftMaterial != fs::last_write_time(m_matPath)){

            LOG << "** Changes made to Recc files" << ENDL;
            LOG << "** Recalculation ..." << ENDL;
            LOG << ENDL;

            return false;
    }

    LOG << "** No Changes made to Recc files" << ENDL;
    LOG << "** Loading results with " << bs.size() << " bytes from cache - " << ENDL;
    LOG << ENDL;

    bs.extractMultiple(
        m_simulationSteps, m_deltaTime, m_simulationTime,
        modelDistance, maxModelExtent, modelExtend, modelCenter,
        m_simulationFrames,
        data_lowerXi, data_upperXi, u_lowerXi, u_upperXi, n_lowerXi, n_upperXi,
        m_samples, m_mean, m_deviation,
        m_isoMesh,
        m_materialIsLinear,
        upperXi,
        lowerXi
        );

    return true;
}

void FemModel::validateCachedResults(){

    if(!initialzed()){

        LOG << "!! Model nicht initialisiert" << ENDL;
        return;
    }

    LOG << "** validiere cache " << m_resCachePath << ENDL;

    ByteSequence bs;
    bs.fromFile(m_resCachePath);
    bs.decode(m_encoderKey);

    fileTime ftMesh, ftConstraints, ftMaterial;
    bs.extractMultiple(ftMaterial, ftConstraints, ftMesh);

    bs.insertMultiple(fs::last_write_time(m_meshPath), fs::last_write_time(m_constraintPath), fs::last_write_time(m_matPath));
    bs.encode(m_encoderKey);
    bs.toFile(m_resCachePath);
}

void FemModel::cacheResults(){

    ByteSequence bs;

    //
    bs.insertMultiple(
        lowerXi,
        upperXi,
        m_materialIsLinear,
        m_isoMesh,
        m_deviation, m_mean, m_samples,
        n_upperXi, n_lowerXi, u_upperXi, u_lowerXi, data_upperXi, data_lowerXi,
        m_simulationFrames,
        modelCenter, modelExtend, maxModelExtent, modelDistance,
        m_simulationTime, m_deltaTime, m_simulationSteps
    );

    bs.insertMultiple(fs::last_write_time(m_meshPath), fs::last_write_time(m_constraintPath), fs::last_write_time(m_matPath));
    
    LOG << "** Write Cache to " << m_resCachePath << ENDL;

    timePoint start = chrono::now();

    bs.encode(m_encoderKey);
    bs.toFile(m_resCachePath);

    LOG << "-- Cache und Encoding " << (chrono::now() - start).count() / 1000000000.0f << " s" << ENDL;
    LOG << "-- Cached Size " << bs.size() << " bytes" << ENDL;
    LOG << ENDL;
}

void FemModel::storeResults(){

    RETURNING_ASSERT(initialzed(), "Model wurde nicht initialisert oder berechnet, Export nicht möglich",);

    //
    nlohmann::ordered_json j;

    //
    bool hasPdf = m_isoMesh.getMaterial().hasPdf;
    bool isLinear = m_isoMesh.getMaterial().isLinear;

    j["isLinear"] = isLinear;
    j["hasPdf"] = hasPdf;

    to_json(j["undeformed Nodes"], m_isoMesh.getUndeformedNodes());

    if(isLinear){

        to_json(j["displacement"], m_isoMesh.m_uSystem);
        to_json(j["cellData"], m_isoMesh.m_cellData);
        to_json(j["deformed Nodes"], m_isoMesh.getDeformedNodes());
    }
    
    if(isLinear && hasPdf){

        to_json(j["lowerXi"], lowerXi);
        to_json(j["upperXi"], upperXi);

        to_json(j["displacement upperXi"], u_upperXi);
        to_json(j["deformed Nodes upperXi"], n_upperXi);
        to_json(j["CellData upperXi"], data_upperXi);

        to_json(j["displacement lowerXi"], u_lowerXi);
        to_json(j["deformed Nodes lowerXi"], n_lowerXi);
        to_json(j["CellData lowerXi"], data_lowerXi);
    }

    if(!isLinear){

        to_json(j["SimulationFrames"], m_simulationFrames);
    }

    //
    std::ofstream file(m_resultFilePath);
    if (file.is_open()) {

        auto now = std::chrono::system_clock::now();
        std::time_t now_c = std::chrono::system_clock::to_time_t(now);

        file << "// ==============================================\n";
        file << "// Simulation Results for Model: " << m_modelPath << "\n";
        file << "// Generated by: ALF (Adaptive, Lightweight Finite Element Tool)\n";
        file << "// Date: " << std::put_time(std::localtime(&now_c), "%Y-%m-%d") << "\n";
        file << "// Time: " << std::put_time(std::localtime(&now_c), "%H:%M:%S") << "\n";
        file << "// ==============================================\n\n";

        file << j.dump(4);
        file.close();
    }
    else {
        _ERROR << "Konnte Datei nicht öffnen!\n";
    }

    LOG << "** Have Written Resultfile " << m_resultFilePath << ENDL;
}